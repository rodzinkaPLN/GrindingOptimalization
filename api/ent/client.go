// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/rodzinkaPLN/GrindingOptimalization/api/ent/migrate"

	"github.com/rodzinkaPLN/GrindingOptimalization/api/ent/datapoint"
	"github.com/rodzinkaPLN/GrindingOptimalization/api/ent/dataset"
	"github.com/rodzinkaPLN/GrindingOptimalization/api/ent/parameter"
	"github.com/rodzinkaPLN/GrindingOptimalization/api/ent/prediction"
	"github.com/rodzinkaPLN/GrindingOptimalization/api/ent/userinput"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Datapoint is the client for interacting with the Datapoint builders.
	Datapoint *DatapointClient
	// Dataset is the client for interacting with the Dataset builders.
	Dataset *DatasetClient
	// Parameter is the client for interacting with the Parameter builders.
	Parameter *ParameterClient
	// Prediction is the client for interacting with the Prediction builders.
	Prediction *PredictionClient
	// Userinput is the client for interacting with the Userinput builders.
	Userinput *UserinputClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Datapoint = NewDatapointClient(c.config)
	c.Dataset = NewDatasetClient(c.config)
	c.Parameter = NewParameterClient(c.config)
	c.Prediction = NewPredictionClient(c.config)
	c.Userinput = NewUserinputClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		Datapoint:  NewDatapointClient(cfg),
		Dataset:    NewDatasetClient(cfg),
		Parameter:  NewParameterClient(cfg),
		Prediction: NewPredictionClient(cfg),
		Userinput:  NewUserinputClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:        ctx,
		config:     cfg,
		Datapoint:  NewDatapointClient(cfg),
		Dataset:    NewDatasetClient(cfg),
		Parameter:  NewParameterClient(cfg),
		Prediction: NewPredictionClient(cfg),
		Userinput:  NewUserinputClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Datapoint.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Datapoint.Use(hooks...)
	c.Dataset.Use(hooks...)
	c.Parameter.Use(hooks...)
	c.Prediction.Use(hooks...)
	c.Userinput.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.Datapoint.Intercept(interceptors...)
	c.Dataset.Intercept(interceptors...)
	c.Parameter.Intercept(interceptors...)
	c.Prediction.Intercept(interceptors...)
	c.Userinput.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DatapointMutation:
		return c.Datapoint.mutate(ctx, m)
	case *DatasetMutation:
		return c.Dataset.mutate(ctx, m)
	case *ParameterMutation:
		return c.Parameter.mutate(ctx, m)
	case *PredictionMutation:
		return c.Prediction.mutate(ctx, m)
	case *UserinputMutation:
		return c.Userinput.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// DatapointClient is a client for the Datapoint schema.
type DatapointClient struct {
	config
}

// NewDatapointClient returns a client for the Datapoint from the given config.
func NewDatapointClient(c config) *DatapointClient {
	return &DatapointClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `datapoint.Hooks(f(g(h())))`.
func (c *DatapointClient) Use(hooks ...Hook) {
	c.hooks.Datapoint = append(c.hooks.Datapoint, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `datapoint.Intercept(f(g(h())))`.
func (c *DatapointClient) Intercept(interceptors ...Interceptor) {
	c.inters.Datapoint = append(c.inters.Datapoint, interceptors...)
}

// Create returns a builder for creating a Datapoint entity.
func (c *DatapointClient) Create() *DatapointCreate {
	mutation := newDatapointMutation(c.config, OpCreate)
	return &DatapointCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Datapoint entities.
func (c *DatapointClient) CreateBulk(builders ...*DatapointCreate) *DatapointCreateBulk {
	return &DatapointCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Datapoint.
func (c *DatapointClient) Update() *DatapointUpdate {
	mutation := newDatapointMutation(c.config, OpUpdate)
	return &DatapointUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DatapointClient) UpdateOne(d *Datapoint) *DatapointUpdateOne {
	mutation := newDatapointMutation(c.config, OpUpdateOne, withDatapoint(d))
	return &DatapointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DatapointClient) UpdateOneID(id uuid.UUID) *DatapointUpdateOne {
	mutation := newDatapointMutation(c.config, OpUpdateOne, withDatapointID(id))
	return &DatapointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Datapoint.
func (c *DatapointClient) Delete() *DatapointDelete {
	mutation := newDatapointMutation(c.config, OpDelete)
	return &DatapointDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DatapointClient) DeleteOne(d *Datapoint) *DatapointDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DatapointClient) DeleteOneID(id uuid.UUID) *DatapointDeleteOne {
	builder := c.Delete().Where(datapoint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DatapointDeleteOne{builder}
}

// Query returns a query builder for Datapoint.
func (c *DatapointClient) Query() *DatapointQuery {
	return &DatapointQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDatapoint},
		inters: c.Interceptors(),
	}
}

// Get returns a Datapoint entity by its id.
func (c *DatapointClient) Get(ctx context.Context, id uuid.UUID) (*Datapoint, error) {
	return c.Query().Where(datapoint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DatapointClient) GetX(ctx context.Context, id uuid.UUID) *Datapoint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDatasets queries the datasets edge of a Datapoint.
func (c *DatapointClient) QueryDatasets(d *Datapoint) *DatasetQuery {
	query := (&DatasetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(datapoint.Table, datapoint.FieldID, id),
			sqlgraph.To(dataset.Table, dataset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, datapoint.DatasetsTable, datapoint.DatasetsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DatapointClient) Hooks() []Hook {
	return c.hooks.Datapoint
}

// Interceptors returns the client interceptors.
func (c *DatapointClient) Interceptors() []Interceptor {
	return c.inters.Datapoint
}

func (c *DatapointClient) mutate(ctx context.Context, m *DatapointMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DatapointCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DatapointUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DatapointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DatapointDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Datapoint mutation op: %q", m.Op())
	}
}

// DatasetClient is a client for the Dataset schema.
type DatasetClient struct {
	config
}

// NewDatasetClient returns a client for the Dataset from the given config.
func NewDatasetClient(c config) *DatasetClient {
	return &DatasetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dataset.Hooks(f(g(h())))`.
func (c *DatasetClient) Use(hooks ...Hook) {
	c.hooks.Dataset = append(c.hooks.Dataset, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dataset.Intercept(f(g(h())))`.
func (c *DatasetClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dataset = append(c.inters.Dataset, interceptors...)
}

// Create returns a builder for creating a Dataset entity.
func (c *DatasetClient) Create() *DatasetCreate {
	mutation := newDatasetMutation(c.config, OpCreate)
	return &DatasetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dataset entities.
func (c *DatasetClient) CreateBulk(builders ...*DatasetCreate) *DatasetCreateBulk {
	return &DatasetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dataset.
func (c *DatasetClient) Update() *DatasetUpdate {
	mutation := newDatasetMutation(c.config, OpUpdate)
	return &DatasetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DatasetClient) UpdateOne(d *Dataset) *DatasetUpdateOne {
	mutation := newDatasetMutation(c.config, OpUpdateOne, withDataset(d))
	return &DatasetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DatasetClient) UpdateOneID(id uuid.UUID) *DatasetUpdateOne {
	mutation := newDatasetMutation(c.config, OpUpdateOne, withDatasetID(id))
	return &DatasetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dataset.
func (c *DatasetClient) Delete() *DatasetDelete {
	mutation := newDatasetMutation(c.config, OpDelete)
	return &DatasetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DatasetClient) DeleteOne(d *Dataset) *DatasetDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DatasetClient) DeleteOneID(id uuid.UUID) *DatasetDeleteOne {
	builder := c.Delete().Where(dataset.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DatasetDeleteOne{builder}
}

// Query returns a query builder for Dataset.
func (c *DatasetClient) Query() *DatasetQuery {
	return &DatasetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDataset},
		inters: c.Interceptors(),
	}
}

// Get returns a Dataset entity by its id.
func (c *DatasetClient) Get(ctx context.Context, id uuid.UUID) (*Dataset, error) {
	return c.Query().Where(dataset.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DatasetClient) GetX(ctx context.Context, id uuid.UUID) *Dataset {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParameters queries the parameters edge of a Dataset.
func (c *DatasetClient) QueryParameters(d *Dataset) *ParameterQuery {
	query := (&ParameterClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dataset.Table, dataset.FieldID, id),
			sqlgraph.To(parameter.Table, parameter.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dataset.ParametersTable, dataset.ParametersColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDatapoints queries the datapoints edge of a Dataset.
func (c *DatasetClient) QueryDatapoints(d *Dataset) *DatapointQuery {
	query := (&DatapointClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dataset.Table, dataset.FieldID, id),
			sqlgraph.To(datapoint.Table, datapoint.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dataset.DatapointsTable, dataset.DatapointsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DatasetClient) Hooks() []Hook {
	return c.hooks.Dataset
}

// Interceptors returns the client interceptors.
func (c *DatasetClient) Interceptors() []Interceptor {
	return c.inters.Dataset
}

func (c *DatasetClient) mutate(ctx context.Context, m *DatasetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DatasetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DatasetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DatasetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DatasetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dataset mutation op: %q", m.Op())
	}
}

// ParameterClient is a client for the Parameter schema.
type ParameterClient struct {
	config
}

// NewParameterClient returns a client for the Parameter from the given config.
func NewParameterClient(c config) *ParameterClient {
	return &ParameterClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `parameter.Hooks(f(g(h())))`.
func (c *ParameterClient) Use(hooks ...Hook) {
	c.hooks.Parameter = append(c.hooks.Parameter, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `parameter.Intercept(f(g(h())))`.
func (c *ParameterClient) Intercept(interceptors ...Interceptor) {
	c.inters.Parameter = append(c.inters.Parameter, interceptors...)
}

// Create returns a builder for creating a Parameter entity.
func (c *ParameterClient) Create() *ParameterCreate {
	mutation := newParameterMutation(c.config, OpCreate)
	return &ParameterCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Parameter entities.
func (c *ParameterClient) CreateBulk(builders ...*ParameterCreate) *ParameterCreateBulk {
	return &ParameterCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Parameter.
func (c *ParameterClient) Update() *ParameterUpdate {
	mutation := newParameterMutation(c.config, OpUpdate)
	return &ParameterUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ParameterClient) UpdateOne(pa *Parameter) *ParameterUpdateOne {
	mutation := newParameterMutation(c.config, OpUpdateOne, withParameter(pa))
	return &ParameterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ParameterClient) UpdateOneID(id uuid.UUID) *ParameterUpdateOne {
	mutation := newParameterMutation(c.config, OpUpdateOne, withParameterID(id))
	return &ParameterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Parameter.
func (c *ParameterClient) Delete() *ParameterDelete {
	mutation := newParameterMutation(c.config, OpDelete)
	return &ParameterDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ParameterClient) DeleteOne(pa *Parameter) *ParameterDeleteOne {
	return c.DeleteOneID(pa.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ParameterClient) DeleteOneID(id uuid.UUID) *ParameterDeleteOne {
	builder := c.Delete().Where(parameter.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ParameterDeleteOne{builder}
}

// Query returns a query builder for Parameter.
func (c *ParameterClient) Query() *ParameterQuery {
	return &ParameterQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeParameter},
		inters: c.Interceptors(),
	}
}

// Get returns a Parameter entity by its id.
func (c *ParameterClient) Get(ctx context.Context, id uuid.UUID) (*Parameter, error) {
	return c.Query().Where(parameter.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ParameterClient) GetX(ctx context.Context, id uuid.UUID) *Parameter {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDatasets queries the datasets edge of a Parameter.
func (c *ParameterClient) QueryDatasets(pa *Parameter) *DatasetQuery {
	query := (&DatasetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pa.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(parameter.Table, parameter.FieldID, id),
			sqlgraph.To(dataset.Table, dataset.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, parameter.DatasetsTable, parameter.DatasetsColumn),
		)
		fromV = sqlgraph.Neighbors(pa.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ParameterClient) Hooks() []Hook {
	return c.hooks.Parameter
}

// Interceptors returns the client interceptors.
func (c *ParameterClient) Interceptors() []Interceptor {
	return c.inters.Parameter
}

func (c *ParameterClient) mutate(ctx context.Context, m *ParameterMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ParameterCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ParameterUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ParameterUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ParameterDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Parameter mutation op: %q", m.Op())
	}
}

// PredictionClient is a client for the Prediction schema.
type PredictionClient struct {
	config
}

// NewPredictionClient returns a client for the Prediction from the given config.
func NewPredictionClient(c config) *PredictionClient {
	return &PredictionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `prediction.Hooks(f(g(h())))`.
func (c *PredictionClient) Use(hooks ...Hook) {
	c.hooks.Prediction = append(c.hooks.Prediction, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `prediction.Intercept(f(g(h())))`.
func (c *PredictionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Prediction = append(c.inters.Prediction, interceptors...)
}

// Create returns a builder for creating a Prediction entity.
func (c *PredictionClient) Create() *PredictionCreate {
	mutation := newPredictionMutation(c.config, OpCreate)
	return &PredictionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Prediction entities.
func (c *PredictionClient) CreateBulk(builders ...*PredictionCreate) *PredictionCreateBulk {
	return &PredictionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Prediction.
func (c *PredictionClient) Update() *PredictionUpdate {
	mutation := newPredictionMutation(c.config, OpUpdate)
	return &PredictionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PredictionClient) UpdateOne(pr *Prediction) *PredictionUpdateOne {
	mutation := newPredictionMutation(c.config, OpUpdateOne, withPrediction(pr))
	return &PredictionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PredictionClient) UpdateOneID(id uuid.UUID) *PredictionUpdateOne {
	mutation := newPredictionMutation(c.config, OpUpdateOne, withPredictionID(id))
	return &PredictionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Prediction.
func (c *PredictionClient) Delete() *PredictionDelete {
	mutation := newPredictionMutation(c.config, OpDelete)
	return &PredictionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PredictionClient) DeleteOne(pr *Prediction) *PredictionDeleteOne {
	return c.DeleteOneID(pr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PredictionClient) DeleteOneID(id uuid.UUID) *PredictionDeleteOne {
	builder := c.Delete().Where(prediction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PredictionDeleteOne{builder}
}

// Query returns a query builder for Prediction.
func (c *PredictionClient) Query() *PredictionQuery {
	return &PredictionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrediction},
		inters: c.Interceptors(),
	}
}

// Get returns a Prediction entity by its id.
func (c *PredictionClient) Get(ctx context.Context, id uuid.UUID) (*Prediction, error) {
	return c.Query().Where(prediction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PredictionClient) GetX(ctx context.Context, id uuid.UUID) *Prediction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PredictionClient) Hooks() []Hook {
	return c.hooks.Prediction
}

// Interceptors returns the client interceptors.
func (c *PredictionClient) Interceptors() []Interceptor {
	return c.inters.Prediction
}

func (c *PredictionClient) mutate(ctx context.Context, m *PredictionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PredictionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PredictionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PredictionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PredictionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Prediction mutation op: %q", m.Op())
	}
}

// UserinputClient is a client for the Userinput schema.
type UserinputClient struct {
	config
}

// NewUserinputClient returns a client for the Userinput from the given config.
func NewUserinputClient(c config) *UserinputClient {
	return &UserinputClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userinput.Hooks(f(g(h())))`.
func (c *UserinputClient) Use(hooks ...Hook) {
	c.hooks.Userinput = append(c.hooks.Userinput, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userinput.Intercept(f(g(h())))`.
func (c *UserinputClient) Intercept(interceptors ...Interceptor) {
	c.inters.Userinput = append(c.inters.Userinput, interceptors...)
}

// Create returns a builder for creating a Userinput entity.
func (c *UserinputClient) Create() *UserinputCreate {
	mutation := newUserinputMutation(c.config, OpCreate)
	return &UserinputCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Userinput entities.
func (c *UserinputClient) CreateBulk(builders ...*UserinputCreate) *UserinputCreateBulk {
	return &UserinputCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Userinput.
func (c *UserinputClient) Update() *UserinputUpdate {
	mutation := newUserinputMutation(c.config, OpUpdate)
	return &UserinputUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserinputClient) UpdateOne(u *Userinput) *UserinputUpdateOne {
	mutation := newUserinputMutation(c.config, OpUpdateOne, withUserinput(u))
	return &UserinputUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserinputClient) UpdateOneID(id uuid.UUID) *UserinputUpdateOne {
	mutation := newUserinputMutation(c.config, OpUpdateOne, withUserinputID(id))
	return &UserinputUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Userinput.
func (c *UserinputClient) Delete() *UserinputDelete {
	mutation := newUserinputMutation(c.config, OpDelete)
	return &UserinputDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserinputClient) DeleteOne(u *Userinput) *UserinputDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserinputClient) DeleteOneID(id uuid.UUID) *UserinputDeleteOne {
	builder := c.Delete().Where(userinput.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserinputDeleteOne{builder}
}

// Query returns a query builder for Userinput.
func (c *UserinputClient) Query() *UserinputQuery {
	return &UserinputQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserinput},
		inters: c.Interceptors(),
	}
}

// Get returns a Userinput entity by its id.
func (c *UserinputClient) Get(ctx context.Context, id uuid.UUID) (*Userinput, error) {
	return c.Query().Where(userinput.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserinputClient) GetX(ctx context.Context, id uuid.UUID) *Userinput {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserinputClient) Hooks() []Hook {
	return c.hooks.Userinput
}

// Interceptors returns the client interceptors.
func (c *UserinputClient) Interceptors() []Interceptor {
	return c.inters.Userinput
}

func (c *UserinputClient) mutate(ctx context.Context, m *UserinputMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserinputCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserinputUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserinputUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserinputDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Userinput mutation op: %q", m.Op())
	}
}
